📅 Day 1: Initialize Project + Set Up Server
 -Create project folder: mkdir job_board_api
  make directory called job_board_api, for better organization always first step
 -npm init -y
  npm**
  This command initializes a new Node.js project by automatically creating a package.json file with default settings. You can always edit it later.
   The package.json file is the blueprint of your Node.js project. It includes:
    Project name and version
    Description (optional)
    Entry point file (usually index.js or app.js)
    Scripts (like how to start the app)
    Dependencies (packages you install)
    License and author info
  Without -y
   You’ll be prompted with questions like:
    Project name?
    Version?
    Description?
    Entry point?
    License?
  The -y flag means:
   "Yes to all default options."
  Use npm init -y at the beginning of any Node.js project to:
   Create package.json
   Start tracking your dependencies
   Set up your project cleanly
 -Install core dependencies:
   npm install express pg dotenv jsonwebtoken bcryptjs
    Express is a web framework for Node.js.
     Think of Node.js as the engine of a car, it can drive
     but you need a steering wheel and pedals to control it easily. 
     Express is like that steering wheel and pedals, making it easier to handle web requests, routing, and responses.
     Why use it?
     It handles HTTP requests (GET, POST, PUT, DELETE) from users.
     Makes routing simple, so you can say:
     “When someone goes to /jobs, show job listings.”
     “When someone posts a job, save it in the database.”
     Provides middleware support for things like authentication, parsing JSON, etc.
    pg is a PostgreSQL client library for Node.js.
     Imagine your database is a huge warehouse with millions of boxes (data).
     You need a reliable delivery truck driver who knows how to communicate and retrieve the right boxes for you. pg is that driver.
     Why use it?
      It allows your Node.js app to talk to the PostgreSQL database.
      You send SQL queries through pg and get data back.
      Handles connections, queries, and responses cleanly.
      PostgreSQL***
    dotenv
     dotenv loads environment variables from a .env file into your app.
     .env is like a locked drawer that holds secrets
     dotenv opens that drawer at runtime.
     Why use it?
      Keeps sensitive info (like DB passwords, API keys, JWT secrets) out of your code.
      Lets you easily switch configs between development and production.
      Avoids hardcoding secrets which is a security risk.
    jsonwebtoken
     Think of JWT as a secure digital passport.
     When a user logs in, they get this passport which proves who they are without showing their password every time.
     Why use it?
      Allows stateless authentication: the server doesn’t have to remember logged-in users.
      Securely encodes user info (like user ID) inside a token.
      Clients send the token with requests to prove they’re authenticated.
    bcryptjs
     bcryptjs hashes (encrypts) passwords before saving them.
   npm install --save-dev nodemon
    This command:
     Uses npm (Node Package Manager) to install a package called nodemon
     The flag --save-dev tells npm:
      “This tool is only needed during development, not when the app is running in production.”
      So, the package gets listed in your package.json file under "devDependencies" (instead of "dependencies").
     Think of nodemon as your coding assistant during development
      Normally, when you run your Node.js server using node index.js,
      if you make a change in your code, you have to stop the server and restart it manually.
      With nodemon, your server automatically restarts every time you change a file. It watches your code and reloads the server for you.
 -Create basic folder structure
  job-board-api/
  ├── node_modules/         # Auto-generated by npm
  ├── src/                  # All source code lives here
  │   ├── controllers/      # Functions that respond to requests
  │   ├── models/           # Database queries and schema,  Code to talk to your database (PostgreSQL in this case).
  │   ├── routes/           # Route definitions (like /jobs, /auth), Defines the URLs for your API and connects them to controllers.
  │   ├── middleware/       # Custom middleware (e.g. auth check),Functions that run before your controller logic
  │   ├── config/           # DB connection and app settings,Stores configuration code like database connections or app settings.
  │   ├── utils/            # Helper functions (e.g. token creation),Small reusable functions or helpers used across your app.
  │   └── index.js          # App entry point (main Express setup)
  ├── .env                  # Environment variables (e.g. DB URL, secret keys)
  ├── .gitignore            # Ignore node_modules, .env, etc. Why needed: Prevents uploading unnecessary or sensitive files to version control
  ├── package.json          # Project metadata and dependencies
  ├── README.md             # Project overview and instructions What it is: Project overview, setup instructions, and usage documentation.
  Why needed: Helps others (and future you) understand how your app works and how to run it.
  mkdir job-board-api
  cd job-board-api
  npm init -y  # Creates package.json
  mkdir src
  cd src
  mkdir controllers models routes middleware config utils
  touch index.js
  cd ..
  touch(****) .env .gitignore README.md
 -Create app.js and add simple Express server
  You must import (require) first to get the function, then call it to make your app.
  express() is a function that creates and returns an app object.
  Import express function 
  const express = require('express');
  Create express app calling express function
  const app = express();
  Set the port 
  Think of a port like a door number on a building—this is how people reach your server.
  const PORT = process.env.PORT || 3000;
  process is a global object in Node.js that provides info about, and control over, the current Node process.
  env is a property of process that holds environment variables — key-value pairs set outside your code, usually in your system or in a .env file.
  The process.env property returns an object containing the user environment.
  PORT is the name of one such environment variable, typically used to specify which port your server should listen on.
  Define a route
  app.get(path, handler)
  Handler: A function that runs when someone visits that path
  app.get('/', (req, res) => {
    res.send('Hello from the Express server!');
  });
  In web development, a route defines how your server responds to different HTTP requests at specific paths (like /, /login, /api, etc.).
  If a user visits this URL and sends this kind of request, respond with this.
  .get() is a method that listens for GET requests.
  A GET request is usually made when someone visits a webpage in their browser.
  /' refers to the root path of whatever domain or host you're working on — like http://localhost:3000/
  http://localhost:3000 — This is the full URL
  http: The protocol (like HTTPS or HTTP)
  localhost: The domain (in development, this points to your own computer)
  3000: The port your server is listening on
  So http://localhost:3000 means:
   Connect to my own computer on port 3000 using the HTTP protocol.
  Start the server
  app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
  });
    Hey Node.js, please start listening for requests on the specified port!
    ${PORT} is part of a template literal in JavaScript.
    Use backticks ( ` ` ) instead of quotes.
    Allow you to inject variables directly into the string using ${...}

 -Test with nodemon app.js
✅ Goal: You have a working server with nothing but a health check route (e.g., / returns “API is running”).

📅 Day 2: Set Up Database (Supabase + Schema)
 Create a Supabase project
 Go to SQL editor and run the schema (users and jobs tables)
 Copy the DATABASE_URL and paste it in your .env
 Create db/index.js and test DB connection
✅ Goal: Your project is connected to Supabase and you’ve verified it with a simple query.

📅 Day 3: User Auth – Register/Login
 Create authController.js
 Create authRoutes.js
 Add /api/auth/register and /api/auth/login
 Hash passwords with bcryptjs
 Generate JWT tokens
✅ Goal: You can register users and log in, receiving a token.

📅 Day 4: Middleware & Auth Protection
 Create auth.js middleware
 Protect certain routes (e.g., job creation)
 Add error handling for unauthorized access
✅ Goal: Only logged-in users can access protected routes.

📅 Day 5: Job Posting
 Create jobController.js
 Create jobRoutes.js
 Add route to post a job (only for authenticated users)
 Save user_id with job
✅ Goal: A logged-in user can post a job and it’s saved to the DB.

📅 Day 6: View, Filter, Edit, and Delete Jobs
 Add route to get all jobs (GET /api/jobs)
 Add filtering by job type
 Add update job route (only by owner)
 Add delete job route (only by owner)
✅ Goal: Full CRUD functionality is working.

📅 Day 7: Final Polish & Test
 Test all routes using Postman or Thunder Client
 Validate inputs (optional)
 Clean up code/comments
 Add README.md with instructions
 (Optional) Push to GitHub
✅ Goal: Your API is complete, documented, and working end to end!


This command deletes the folder "" and everything inside it.
rm -rf
-r Tells rm to delete directories and their contents (folders inside folders)
-f force Tells rm to not ask for confirmation, and ignore errors if the file/folder doesn’t exist
Safer Alternative (if you're unsure)
rm -ri 
-i prompts before each delete, giving you control.

**npm stands for Node Package Manager.
It’s the default package manager for Node.js.
It lets you install, manage, and share reusable code packages (libraries).
These packages help you avoid reinventing the wheel — so you can build apps faster.
It also manages your project’s dependencies in a file called package.json.
You run npm commands in your terminal to add or remove packages, run scripts, or publish your own packages.
Node.js is like the engine (runtime) that runs your JavaScript outside the browser.
npm is the toolkit and toolbox that helps you build and manage your projects on that engine.

***What is PostgreSQL?
PostgreSQL (often called Postgres) is a powerful, open-source relational database management system (RDBMS).
Database = a place where you store and organize data (like a digital filing cabinet).
Relational = data is stored in tables with rows and columns, and these tables can be linked (related) to each other.
Management System = software that helps you create, read, update, and delete data easily and safely.

touch**** 
The touch command is used in the terminal to create empty files